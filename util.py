#!/usr/bin/env python -3
# encoding: utf-8

#Created by Graham Cummins on 
#Mon Feb 28 12:56:36 CST 2011

# Copyright (C) 2011 Graham I Cummins
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later 
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT 
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA 02111-1307 USA
#

from __future__ import print_function, unicode_literals
import numpy as np
import gicdat.doc as gd
import re

class AcTabL(dict):
	def __setitem__(self, k, v):
		self[k].append(v)
	
	def __getitem__(self, k):
		try:
			l=dict.__getitem__(self, k)
		except KeyError:
			l = []
			dict.__setitem__(self, k, l)
		return l
		
class AcTabS(dict):
	def __setitem__(self, k, v):
		self[k].add(v)
	
	def __getitem__(self, k):
		try:
			l=dict.__getitem__(self, k)
		except KeyError:
			l = set()
			dict.__setitem__(self, k, l)
		return l

class CountTab(dict):
	def __setitem__(self, k, v):
		dict.__setitem__(self, k, v+self[k])
		
	def inc(self, k):
		self[k]=1
	
	def __getitem__(self, k):
		try:
			return dict.__getitem__(self, k)
		except KeyError:
			return 0

class KeySet(object):
	'''
	provides unique numbered keys for a document, with some prefix
	'''
	def __init__(self, doc, pref=None):
		self.doc = doc
		if pref == None:
			pref = self.getpref(doc)
		self.pref = pref
		self.n = 0
		self.check()
		
	def getpref(self, d):
		z = re.compile("(.*\D)(\d+)$")
		ks ={}
		for k in d:
			m = z.match(k)
			if m:
				p = m.groups()[0]
				if not p in ks:
					ks[p] = 1
				else:
					ks[p] = ks[p]+1
		m= 0
		p = '_'
		for k in ks:
			if ks[k]>m:
				p = k
				m = ks[k]
		return p
	
	def __len__(self):
		return self.n
	
	def __getitem__(self, i):
		return self.doc["%s%i" % (self.pref,i)]

	def pfnkey(self, k):
		if k.startswith(self.pref):
			try:
				n = int(k[len(self.pref):])
				return n
			except:
				pass
		return -1
		
	def keys(self):
		keys = []
		ns = []
		for k in self.doc.keys():
			n = self.pfnkey(k)
			if n > -1:
				keys.append(k)
				ns.append(n)
		return [keys[i] for i in np.argsort(np.array(ns))]
	
	def __iter__(self):
		return self.keys().__iter__()
	
	def set(self, key, val):
		ks = self.keys()
		if type(val)==list and len(val) == len(ks):
			for i, k in enumerate(ks):
				self.doc[k][key] = val[i]
		else:
			for k in ks:
				self.doc[k][key] = val
			if val == None:
				self.doc.clean()
			
	
	def map(self, f, name=None):
		nd = self.doc.new()
		for k in self.keys():
			r = f(self.doc[k])
			if name:
				nd[k+'.'+name] =r
			else:
				nd[k] = r
		return nd
	
	def check(self):
		'''
		Set self.n large enough that the next call to "next" is certain to be unique in Doc. If 
		keys with this prefix are only generated by this instance, there is no need to call 
		this method, but on creation, and if other methods have been used to add keys to self.doc 
		it may be required.
		'''
		for k in self.doc.keys():
			n = self.pfnkey(k)
			self.n = max(n, self.n)

	def next(self):
		self.n+=1
		return "%s%i" % (self.pref, self.n)


def padrange(r, pad=.01, scale=1.0):
	'''
	r is a sequence of float . Returns a 2-tuple of float (mi-p, ma+p) where
	mi = min(r)/scale, ma = max(r)/scale p = (ma-mi)*pad
	
	'''
	ma = max(r)/scale
	mi = min(r)/scale
	p = (ma - mi)*pad
	return ( mi-p, ma+p)

def hist(samps, binwidth, start, nbins=None):
	'''
	Much faster, slightly less flexible histogram function. Binwidth is the
	size of each bin, and start is the location of the first bin. If nbins is
	specified, the return vector will be forced to have that length (by
	cropping or zero padding as needed)
	
	'''
	samps=(samps-start)/binwidth
	samps=samps.astype(np.int32)
	hist=np.bincount(samps).astype(np.int32)
	if nbins:
		if hist.shape[0]>nbins:
			hist=hist[:nbins]
		elif hist.shape[0]<nbins:
			pad=nbins-hist.shape[0]
			pad=np.zeros(pad, hist.dtype)
			hist=np.concatenate([hist, pad])
	return hist	

def combine(ranges):
	'''
	All combinations of the items in the list of lists "ranges" which 
	contain one item from each sublist
	
	'''
	if len(ranges) == 1:
		return [[x] for x in ranges[0] ] 
	else:
		sp = []
		rhs = combine(ranges[1:])
		for v in ranges[0]:
			sp.extend([[v]+l for l in rhs])
		return sp

def drawpd(pd):
	'''
	return a sample from the distribution pd (represented as a vector)
	
	'''
	pdf = np.cumsum(pd)
	z = np.random.uniform(0, pdf[-1])
	i = np.nonzero(pdf >= z)[0][0]
	return i


def infdiag(m):
	'''
	return a matrix identical to m but with np.inf on the diagonal (prevents a
	nearest neighbor measure from claiming x's nearest neighbor is x.
	
	'''
	dadj = np.diag(np.ones(m.shape[0])*np.inf)
	return m+dadj


def maxdiag(m):
	'''
	return a matrix identical to m but with np.inf on the diagonal (prevents a
	nearest neighbor measure from claiming x's nearest neighbor is x.
	
	'''
	dadj = np.diag(np.ones(m.shape[0])*m.max())
	return m+dadj

def conditions(d, skeys=[]):
	'''
	d is a gicdat.doc.Doc, and skeys is a list of strings. Return as a Doc
	containing a key for each key in d that references a subdocument which
	defines at least one key from skeys. Each of these keys has an integer
	value, which represents a unique combination of values for the keys in
	skeys. Additionally, the return document has a key "_conditions", with
	subkeys "c#", which provide the values of the specified skeys that represent
	unique combination "#". For example, if d contains: t1.foo =1, t1.bar=2,
	t2.foo=1, t2.bar=1, t3.foo=2, t4.foo=1, t4.bar=2 the return for
	conditions(d, ['foo', 'bar']) would be t1 = 0, t2 = 1, t3 = 2, t4 = 0,
	_conditions.c0.foo = 1, _conditions.c0.bar=2, _conditions.c1.foo=1,
	_conditions.c1,bar=1, _conditions.c2.foo=2, _conditions.c.bar=None
	
	Note that this only works if all condition values are hashable, so none of the 
	subdocuments may have values for any of the skeys that are array or subdoc type.
	Any subdocs that fail this criterion will be left out of the computation.
	'''
	uvcs = {}
	sets = gd.Doc()
	for k in d.keys(-1, subdockeys='only'):
		v = tuple([d[k][sk] for sk in skeys])
		if not any(v):
			continue
		try:
			[hash(x) for x in v]
		except TypeError:
			continue
		if v in uvcs:
			sets[k] = uvcs[v]
		else:
			id = len(uvcs)
			uvcs[v] = id
			sets[k] = uvcs[v]
	for k in uvcs:
		sets["_conditions.c%i" % uvcs[k]] = gd.Doc([(sk, k[i]) for i, sk in enumerate(skeys)])
	return sets		


def nkset(d, keys):
	"""
	d: Doc, keys: [ of s -> [ of s
	
	If keys is length 1, this is equivalent to d.keys(0, keys[0]) (finds all
	keys at the top level of d starting with the string keys[0].)
	
	If keys is lenger list, this function is recursive, first finding sk =
	d.keys(0, keys[0]), and then calling nkset(d[k], keys[1:]) for k in sk. The
	returned value is always a flat list of top-level keys for d, using dot
	notation.
	
	"""
	rv = d.keys(0, keys[0])
	if len(keys)>1:
		nrv = []
		for k in rv:
			for sk in nkset(d[k], keys[1:]):
				nrv.append(k+'.'+sk)
		rv = nrv
	return rv
	

def traverse(d, keys, f, args=(), kwargs=None,out='patch'):
	"""
	d: Doc, keys: s | [ of s, f: callable, args,kwargs: Args(f), 
		out:'new'|'patch'|'mod' -> Doc
		
	If keys is a string, then it should be a KeySet prefix for d, and this
	function will generate a document nd such that 
		nd[k] =f(d[k], *args, **kwargs) for k in d.keys(0, keys)
			
	If keys is a list of strings, then traverse opperates recursively, executing
		nd[k] = traverse(d[k], keys[1:], ...)) for k in d.keys(0, keys[0])
	
	the parameter "out" determines what is returned:
	
	"new": d.fuse(nd)
	"patch": nd
	"mod": execute d.patch(nd) (changing d in place), and return d
	
	"""
	if not kwargs:
		kwargs = {}
	nd = gd.Doc()
	if type(keys) in [str, unicode]:
		keys = [keys]
	keys = nkset(d, keys)
	for k in keys:
		nd[k] = f(d[k], *args, **kwargs)
	if out == 'new':
		return d.fuse(nd)
	elif out == 'mod':
		d.patch(nd)
		return d
	else:
		return nd
